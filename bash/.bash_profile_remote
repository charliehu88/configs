# Compatibility notes:
# - "ls" does not support long flags on macOS.
# - "mkdir" does not support "--parents" on macOS, so we use "-p" instead.
# - "sed" does not support long flags on macOS, but we require that macOS users install "gnu-sed"
#   from Brew.

# region: Constants
# ---------
# Constants
# ---------

CSPELL_IGNORED_WORDS="knip,mypy,pyproject,pyright,pytest,shellcheck,sqlfluff,yamlfix"

# endregion

# region: Helper functions
# ----------------
# Helper functions
# ----------------

add-logix-cert-to-requests-ca-bundle() (
  set -euo pipefail # Exit on errors and undefined variables.

  if [[ -z "${REQUESTS_CA_BUNDLE:-}" ]]; then
    return
  fi

  if [[ ! -s "$REQUESTS_CA_BUNDLE" ]]; then
    echo "Error: The \"REQUESTS_CA_BUNDLE\" environment variable is set to \"$REQUESTS_CA_BUNDLE\", but this file does not exist or is 0 bytes." >&2
    return 1
  fi

  local certificate_name="BEDROOTCA001"
  if ! grep --quiet "$certificate_name" "$REQUESTS_CA_BUNDLE"; then
    echo "Error: The \"REQUESTS_CA_BUNDLE\" environment variable is set to \"$REQUESTS_CA_BUNDLE\", but this file does not have the \"$certificate_name\" certificate in it." >&2
    local file_path="$REQUESTS_CA_BUNDLE"
    if command -v cygpath &> /dev/null; then
      file_path=$(cygpath --windows "$file_path")
    fi

    echo >&2
    echo "Run this command to fix it:" >&2
    echo >&2
    echo "{ echo; echo \"# $certificate_name\"; curl --silent --fail --show-error --location \"https://raw.githubusercontent.com/Zamiell/configs/refs/heads/main/certs/$certificate_name.crt\"; } >> \"$REQUESTS_CA_BUNDLE\"" >&2
    return 1
  fi
)

# If we use a subshell, the changes to PATH would be lost.
append-path() {
  if [[ -z "${1:-}" ]]; then
    echo "Error: The path is required. Usage: ${FUNCNAME[0]} <path>" >&2
    return 1
  fi
  local directory="$1"

  # Check if the directory exists and is not already in the PATH.
  if [[ -d "$directory" ]] && [[ ":$PATH:" != *":$directory:"* ]]; then
    export PATH="$PATH:$directory"
  fi
}

assert-feature-branch() (
  set -euo pipefail # Exit on errors and undefined variables.

  local branch_name
  branch_name=$(git branch --show-current)

  local main_branch_name
  main_branch_name=$(get-main-branch-name)

  if [[ "$branch_name" == "$main_branch_name" ]]; then
    echo "Error: This command is intended to be run on a feature branch and you are currently on the \"$main_branch_name\" branch." >&2
    return 1
  fi
)

assert-in-git-repository() (
  set -euo pipefail # Exit on errors and undefined variables.

  local directory="${1-}"
  if [[ -z "$directory" ]]; then
    directory="$PWD"
  fi

  if [[ ! -d "$directory" ]]; then
    echo "Error: The provided directory does not exist: $directory" >&2
    return 1
  fi

  if ! git -C "$directory" rev-parse --is-inside-work-tree &> /dev/null; then
    echo "Error: The \"$directory\" directory is not inside a Git repository." >&2
    return 1
  fi
)

assert-in-github-repository() (
  set -euo pipefail # Exit on errors and undefined variables.

  local directory="${1-}"
  if [[ -z "$directory" ]]; then
    directory="$PWD"
  fi

  assert-in-git-repository "$directory"

  if ! is-github-repository; then
    echo "Error: The \"$directory\" directory is not inside a GitHub repository." >&2
    return 1
  fi
)

assert-jq-installed() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! command -v jq &> /dev/null; then
    echo "Error: jq is required to use this command. If you are on Windows, you can install it with: winget install --exact --id jqlang.jq" >&2
    return 1
  fi
)

assert-main-branch() (
  set -euo pipefail # Exit on errors and undefined variables.

  local branch_name
  branch_name=$(git branch --show-current)

  local main_branch_name
  main_branch_name=$(get-main-branch-name)

  if [[ "$branch_name" != "$main_branch_name" ]]; then
    echo "Error: This command is intended to be run on the \"$main_branch_name\" branch and you are currently on the \"$branch_name\" branch." >&2
    return 1
  fi
)

# Host-aware Azure DevOps PAT validation
azdo_pat_check() (
  set -euo pipefail

  read -r host organization project _repo <<< "$(get-git-remote-details)"

  local domain personal_access_token
  if [[ "$host" == "azure-devops-server" ]]; then
    domain="azuredevops.logixhealth.com"
    if [[ -z "${AZDO_PERSONAL_ACCESS_TOKEN_SERVER:-}" ]] && [[ -n "${AZDO_PERSONAL_ACCESS_TOKEN:-}" ]]; then
      AZDO_PERSONAL_ACCESS_TOKEN_SERVER="$AZDO_PERSONAL_ACCESS_TOKEN"
    fi
    personal_access_token="${AZDO_PERSONAL_ACCESS_TOKEN_SERVER:-}"
    if [[ -z "$personal_access_token" ]]; then
      echo "❌ PAT missing: set AZDO_PERSONAL_ACCESS_TOKEN_SERVER for on-prem server." >&2
      return 1
    fi
  elif [[ "$host" == "azure-devops-services" ]]; then
    domain="dev.azure.com"
    if [[ -z "${AZDO_PERSONAL_ACCESS_TOKEN_SERVICES:-}" ]] && [[ -n "${AZDO_PERSONAL_ACCESS_TOKEN:-}" ]]; then
      AZDO_PERSONAL_ACCESS_TOKEN_SERVICES="$AZDO_PERSONAL_ACCESS_TOKEN"
    fi
    personal_access_token="${AZDO_PERSONAL_ACCESS_TOKEN_SERVICES:-}"
    if [[ -z "$personal_access_token" ]]; then
      echo "❌ PAT missing: set AZDO_PERSONAL_ACCESS_TOKEN_SERVICES for Azure DevOps Services." >&2
      return 1
    fi
  else
    echo "❌ Unknown host: $host" >&2
    return 1
  fi

  # newline/whitespace guard
  if printf '%s' "$personal_access_token" | grep -q $'\n'; then
    echo "❌ PAT contains newline(s). Re-export without extra whitespace." >&2
    return 1
  fi

  local api_version="7.0"
  local url
  if [[ "$host" == "azure-devops-server" ]]; then
    url="https://${domain}/${organization}/_apis/projects?api-version=${api_version}"
  else
    # Services URL pattern
    url="https://${domain}/${organization}/_apis/projects?api-version=${api_version}"
  fi

  # Try a minimal authenticated GET and surface server errors
  local headers_file
  headers_file="$(mktemp)"
  trap 'rm -f "$headers_file"' EXIT
  if ! curl --silent --fail --show-error --location \
    --user ":$personal_access_token" \
    --dump-header "$headers_file" \
    "$url" > /dev/null; then
    # Try to decode X-TFS-ServiceError if provided
    local reason
    reason="$(grep -i '^x-tfs-serviceerror:' "$headers_file" | sed 's/^x-tfs-serviceerror:[[:space:]]*//I')"
    if [[ -n "$reason" ]]; then
      # decode percent-encoding
      reason="$(
        python - << 'PY'
import sys, urllib.parse
print(urllib.parse.unquote(sys.stdin.read().strip()))
PY
        <<< "$reason"
      )"
      echo "❌ Azure DevOps auth failed: ${reason}" >&2
    else
      echo "❌ Azure DevOps auth failed (check PAT validity/scopes/expiry)." >&2
    fi

    if [[ "$host" == "azure-devops-services" ]]; then
      echo "Hint: For Services, ensure the PAT has at least 'Code (Read & Write)' scope." >&2
    else
      echo "Hint: For Server, ensure PAT is valid and not expired; scope should include 'Code (Read & Write)'." >&2
    fi
    return 1
  fi

  echo "✅ Azure DevOps PAT valid ($host)"
)

# This will echo back the same input if the input is not a number.
get-branch-name-from-number() (
  set -euo pipefail # Exit on errors and undefined variables.

  if [[ -z "${1:-}" ]]; then
    echo "Error: The branch name or number is required. Usage: ${FUNCNAME[0]} <branch_name_or_number>" >&2
    return 1
  fi
  local branch_name_or_number="$1"

  local branch_name
  if [[ "$branch_name_or_number" =~ ^[0-9]+$ ]]; then
    local branch_number="$branch_name_or_number"

    local local_branches
    local_branches=$(git branch --format="%(refname:lstrip=2)" | sort)

    branch_name=$(echo "$local_branches" | sed --quiet "${branch_number}p")
    if [[ -z "$branch_name" ]]; then
      echo "Error: Branch number $branch_number does not exist." >&2
      return 1
    fi
  else
    branch_name="$branch_name_or_number"
  fi

  echo "$branch_name"
)

get-first-branch-commit-description() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert-in-git-repository
  assert-feature-branch

  local branch_name
  branch_name=$(git branch --show-current)

  local main_branch_name
  main_branch_name=$(get-main-branch-name)

  local merge_base
  merge_base=$(get-merge-base)

  local first_commit_hash
  first_commit_hash=$(git rev-list --reverse "$merge_base..$branch_name" | head -n 1)
  if [[ -z "$first_commit_hash" ]]; then
    echo "Error: There are no commits on this branch when compared to the \"$main_branch_name\" branch." >&2
    return 1
  fi

  printf "%s" "$(git show --no-patch --format="%B" "$first_commit_hash")"
)

get-git-remote-details() (
  set -euo pipefail

  local directory="${1-}"
  if [[ -z "$directory" ]]; then
    directory="$PWD"
  fi

  if [[ ! -d "$directory" ]]; then
    echo "Error: The provided directory does not exist: $directory" >&2
    return 1
  fi

  assert-in-git-repository "$directory"

  local remote_url
  remote_url=$(git -C "$directory" remote get-url origin)

  local clean_url="${remote_url%.git}" # Remove the trailing ".git".
  local repository="${clean_url##*/}"  # Everything after the final slash.

  if [[ -z "$repository" ]]; then
    echo "Error: Unable to parse the repository from the git remote: $remote_url" >&2
    return 1
  fi

  if echo "$remote_url" | grep --quiet "github.com"; then
    local host="github"

    local author
    if [[ "$remote_url" == git@* ]]; then
      # SSH URL format: git@github.com:alice/my-repo.git
      author=$(echo "$remote_url" | sed --regexp-extended 's/^git@github\.com:([^/]+)\/.*\.git/\1/')
    else
      # HTTPS URL format: https://github.com/alice/my-repo.git
      author=$(echo "$remote_url" | sed --regexp-extended 's|https://github\.com/([^/]+)/.*\.git|\1|')
    fi

    # Check if we are on a branch created with "gh pr checkout".
    set-gh-remote
    local branch_name
    branch_name=$(git branch --show-current)
    local remote_config
    # This should be equal to "origin" or the GitHub username.
    remote_config=$(git -C "$directory" config "branch.$branch_name.remote")
    if [[ "$remote_config" != "origin" ]]; then
      author="$remote_config"
    fi

    echo "$host $author $repository"
    return
  fi

  if echo "$remote_url" | grep --quiet "dev.azure.com"; then
    local host="azure-devops-services"

    local organization
    local project
    if [[ "$remote_url" == git@ssh* ]]; then
      # git@ssh.dev.azure.com:v3/organization/project/repository
      organization=$(echo "$remote_url" | sed --regexp-extended 's|^git@ssh\.dev\.azure\.com:v3/([^/]+)/.*|\1|')
      project=$(echo "$remote_url" | sed --regexp-extended 's|^git@ssh\.dev\.azure\.com:v3/[^/]+/([^/]+)/.*|\1|')
    else
      # https://dev.azure.com/organization/project/_git/repository
      organization=$(echo "$remote_url" | awk -F'/' '{print $(NF-3)}')
      project=$(echo "$remote_url" | awk -F'/' '{print $(NF-2)}')
    fi

    echo "$host $organization $project $repository"
    return
  fi

  if echo "$remote_url" | grep --quiet "azuredevops.logixhealth.com"; then
    local host="azure-devops-server"
    local organization
    organization=$(echo "$remote_url" | awk -F'/' '{print $(NF-3)}')
    local project
    project=$(echo "$remote_url" | awk -F'/' '{print $(NF-2)}')

    echo "$host $organization $project $repository"
    return
  fi

  echo "Error: Unable to parse the host from the git remote: $remote_url" >&2
  return 1
)

# This will return a descriptive commit message based on the currently staged files.
get-llm-commit-message() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert-in-git-repository

  if [[ -z "${GEMINI_API_KEY:-}" ]]; then
    echo "Error: The \"GEMINI_API_KEY\" environment variable is not set." >&2
    return 1
  fi

  local git_diff
  git_diff=$(git diff --cached)

  if [[ -z "$git_diff" ]]; then
    echo "Error: There are no staged changes in the current Git repository." >&2
    return 1
  fi

  get-llm-output-git-diff "$git_diff" "commit message"
)

# This will return a pull request description based on differences between the current branch and
# the main branch. (Similar to a commit message, the title will be on the first line and the
# description will be on the second line, if any.)
get-llm-pull-request-text() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert-in-git-repository
  assert-feature-branch

  local main_branch_name
  main_branch_name=$(get-main-branch-name)

  if [[ -z "${GEMINI_API_KEY:-}" ]]; then
    echo "Error: The \"GEMINI_API_KEY\" environment variable is not set." >&2
    return 1
  fi

  local git_diff
  git_diff=$(git diff "$main_branch_name"...HEAD)

  if [[ -z "$git_diff" ]]; then
    echo "Error: There are no changes between this branch and the \"$main_branch_name\" branch." >&2
    return 1
  fi

  get-llm-output-git-diff "$git_diff" "pull request description"
)

get-llm-output() (
  set -euo pipefail # Exit on errors and undefined variables.

  if [[ -z "${1:-}" ]]; then
    echo "Error: The system prompt is required. Usage: ${FUNCNAME[0]} <system_prompt> <prompt>" >&2
    return 1
  fi
  local system_prompt="$1"

  if [[ -z "${2:-}" ]]; then
    echo "Error: The prompt is required. Usage: ${FUNCNAME[0]} <system_prompt> <prompt>" >&2
    return 1
  fi
  local prompt="$2"

  # Because there can be a huge amount of data in the git diff, we need to create the API response
  # all in one command. Otherwise, we get errors like "Argument list too long".
  # 1. printf pipes the prompt into jq.
  # 2. jq pipes the JSON payload into curl.
  # 3. curl reads from stdin using "--data @-".
  # Additionally, we have to use the "--ssl-no-revoke" flag with Google URLs when using curl inside
  # Git Bash for Windows, since the LogixHealth Palo Alto blocks the revocation check for some
  # reason.
  local api_url="https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent?key=${GEMINI_API_KEY}"
  local api_response
  api_response=$(
    printf "%s" "$prompt" | jq \
      --raw-input \
      --slurp \
      --arg system_prompt_str "$system_prompt" \
      '{
      "systemInstruction": {
        "parts": [{ "text": $system_prompt_str }]
      },
      "contents": [
        { "parts": [{ "text": . }] }
      ]
     }' | curl \
      --silent \
      --fail \
      --show-error \
      --location \
      --request POST \
      --header "content-type: application/json" \
      --data @- \
      --ssl-no-revoke \
      "$api_url" || {
      local err="$?"
      echo "curl failed on URL: $api_url" >&2
      return "$err"
    }
  )

  if ! echo "$api_response" | jq --exit-status '.candidates' > /dev/null; then
    echo "Error: The LLM API returned an error:" >&2
    echo "$api_response" >&2
    return 1
  fi

  local llm_output
  llm_output=$(echo "$api_response" | jq --raw-output '.candidates[0].content.parts[0].text | select(. != null)')

  if [[ -z "$llm_output" ]]; then
    echo "Error: LLM generation failed." >&2
    return 1
  fi

  echo "$llm_output"
)

get-llm-output-git-diff() (
  set -euo pipefail # Exit on errors and undefined variables.

  if [[ -z "${1:-}" ]]; then
    echo "Error: The git diff is required. Usage: ${FUNCNAME[0]} <git_diff> <noun>" >&2
    return 1
  fi
  local git_diff="$1"

  if [[ -z "${2:-}" ]]; then
    echo "Error: The noun is required. Usage: ${FUNCNAME[0]} <git_diff> <noun>" >&2
    return 1
  fi
  local noun="$2"

  assert-jq-installed

  local system_prompt="You are an expert git commit message generator. You will be given a git diff. Your response must be only the commit message; do not include any preamble, explanation, or markdown. Be concise and descriptive. The commit message is allowed to be more than one line, but only if the changes are complicated. Follow the 50/72 rule. Follow conventional commit standards (e.g. \"feat: add new feature\", \"fix: correct bug\", \"chore: update build\"). Pay particular attention to removed lines, since if a block of code is moved from one place to another, the commit message should not say \"add\", it should say \"move\". If the file being modified is in the \"3_Applications/kubernetes\" directory, then add a commit message scope like \"feat(kubernetes): add variable\". Additionally, the subdirectories of \"3_Applications/containers\" should be scoped to their directory name in the same way. For example, modifying a file in the \"3_Applications/containers/logix-ci-cd-tasks\" directory should result in a commit message like \"feat(logix-ci-cd-tasks): add variable\"."

  local llm_output
  llm_output=$(get-llm-output "$system_prompt" "$git_diff")

  echo -e "$llm_output\n\n(This $noun was automatically generated by an LLM.)"
)

get-main-branch-name() (
  set -euo pipefail # Exit on errors and undefined variables.

  if git show-ref --verify --quiet refs/heads/main; then
    echo "main"
  elif git show-ref --verify --quiet refs/heads/master; then
    echo "master"
  else
    echo "Error: There was not a \"main\" branch or \"master\" branch in this repository." >&2
    return 1
  fi
)

get-merge-base() (
  set -euo pipefail # Exit on errors and undefined variables.

  local branch_name
  branch_name=$(git branch --show-current)

  local main_branch_name
  main_branch_name=$(get-main-branch-name)

  local merge_base
  merge_base=$(git merge-base "$main_branch_name" "$branch_name")
  if [[ -z "$merge_base" ]]; then
    echo "Error: Could not find a common ancestor with the \"$main_branch_name\" branch." >&2
    return 1
  fi

  echo "$merge_base"
)

get-num-commits-on-branch() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert-in-git-repository
  assert-feature-branch

  local branch_name
  branch_name=$(git branch --show-current)

  local merge_base
  merge_base=$(get-merge-base)

  git rev-list --count "$merge_base..$branch_name"
)

is-git-bash() (
  set -euo pipefail # Exit on errors and undefined variables.

  local kernel_name
  kernel_name=$(uname -s) # The "--kernel-name" flag is not supported on MacOS.
  [[ "$kernel_name" =~ ^MINGW || "$kernel_name" =~ ^MSYS_NT ]]
)

is-github-repository() (
  set -euo pipefail # Exit on errors and undefined variables.

  if ! git rev-parse --is-inside-work-tree &> /dev/null; then
    return 1 # False
  fi

  # e.g. "git@github.com:alice/my-repo.git" or "https://github.com/alice/my-repo.git"
  local remote_url
  remote_url=$(git remote get-url origin)

  if echo "$remote_url" | grep --quiet "github.com"; then
    return # True
  fi

  return 1 # False
)

# When we "cd" to a Git repository, we want to show the branches. Otherwise, can we show the list of
# files in the directory.
print-files-and-branches() (
  set -euo pipefail # Exit on errors and undefined variables.

  # We use the same flags as the "ll" alias. (We cannot use the alias directly as the subshell does
  # not have access to it.
  ls -a -h -l -F --color=auto

  # On Git Gash, the "git rev-parse" command will show a directory in the format of:
  # D:/Repositories/configs
  # Thus, we have to made some modifications
  local current_dir="$PWD"
  local repo_root
  repo_root=$(git rev-parse --show-toplevel 2> /dev/null)

  if command -v cygpath &> /dev/null; then
    # "/c/Repositories/foo" --> "C:\Repositories\configs"
    current_dir=$(cygpath --windows "$current_dir")
    current_dir=$(to-lowercase "$current_dir")

    # "C:/Repositories/foo" --> "C:\Repositories\foo"
    repo_root=$(cygpath --windows "$repo_root")
    repo_root=$(to-lowercase "$repo_root")
  fi

  if [[ "$current_dir" == "$repo_root" ]]; then
    echo
    gbl
  fi
)

remove-leading-and-trailing-whitespace() {
  sed --expression '/[^[:space:]]/,$!d' --expression 's/^[[:space:]]*//' --expression 's/[[:space:]]*$//'
}

# - When using "gh pr checkout", the git remote will not be set up properly and "git pull" will have
#   the following error:
#   Your configuration specifies to merge with the ref 'refs/heads/main'
#   from the remote, but no such ref was fetched.
# - This can be seen by typing "git remote", which will only show "origin", even though we are on a
#   branch pointing to a separate repository. Additionally, "git config branch.alice/main.remote"
#   will return "git@github.com:alice/foo.git" instead of "alice".
# - After running this function, "git remote" will return "alice" and "origin", and
#   "git config branch.alice/main.remote" will return "alice".
# - This function will be a no-op if we are not in a GitHub repository or if the remote is already
#   set up properly.
set-gh-remote() (
  set -euo pipefail # Exit on errors and undefined variables.

  local directory="${1-}"
  if [[ -z "$directory" ]]; then
    directory="$PWD"
  fi

  assert-in-git-repository "$directory"

  local branch_name
  branch_name=$(git -C "$directory" branch --show-current)

  # Check to see if this is a branch freshly created from "gh pr checkout".
  local remote_config
  # This will be "origin" on normal branches and "alice" on branches already touched by this
  # function and e.g. "git@github.com:alice/foo.git" or "https://github.com/alice/foo" on branches
  # freshly created from "gh pr checkout".
  remote_config=$(git -C "$directory" config "branch.$branch_name.remote")
  if [[ ! "$remote_config" =~ github\.com[:/]([^/]+)/ ]]; then
    return
  fi

  # First, add a remote for the forked repository.
  local github_username
  github_username="${BASH_REMATCH[1]}"
  local existing_url
  existing_url=$(git -C "$directory" remote get-url "$github_username" 2> /dev/null || true)

  if [[ -n "$existing_url" ]]; then
    # The remote has already been set up on this repository. Verify that it matches.
    if [[ "$existing_url" != "$remote_config" ]]; then
      echo "Error: The remote \"$github_username\" already exists, but it points to \"$existing_url\" instead of \"$remote_config\"." >&2
      return 1
    fi
  else
    # The remote for this username does not already exist.
    git -C "$directory" remote add "$github_username" "$remote_config"

    # Now that the repository has more than one remote, the GitHub CLI will become confused and
    # complain that "no default remote repository has been set" when running commands. Manually set
    # the default to the non-forked remote.
    local origin_url
    origin_url=$(git -C "$directory" remote get-url origin)
    # The GitHub CLI does not support the "-C" flag, so we use a subshell.
    (builtin cd "$directory" && gh repo set-default "$origin_url")
  fi

  git -C "$directory" fetch "$github_username"

  # Second, set the upstream for the current branch. By default, branches created with "gh pr
  # checkout" will not have an upstream, which can be seen with "git branch -vv". If the upstream is
  # already set, this will be a no-op.
  local merge_ref
  # This will be something like: refs/heads/main
  merge_ref=$(git -C "$directory" config branch."$branch_name".merge)
  local branch_short_name
  # This will be something like: main
  branch_short_name=${merge_ref#refs/heads/}
  local target_ref
  # This will be something like: refs/remotes/alice/main
  target_ref="refs/remotes/$github_username/$branch_short_name"
  git -C "$directory" branch --set-upstream-to="$target_ref"

  # Set "push.default" to "upstream". This ensures that "git push" works even when the local branch
  # name (e.g. "pr-123") differs from the remote branch name.
  git -C "$directory" config push.default upstream
)

to-lowercase() (
  set -euo pipefail # Exit on errors and undefined variables.

  if [[ $# -eq 0 ]]; then
    echo "Error: At least one string argument is required. Usage: ${FUNCNAME[0]} <string> ..." >&2
    return 1
  fi

  # https://stackoverflow.com/questions/41166026/what-does-2-commas-after-variable-name-mean-in-bash
  echo "${@,,}"
)

# endregion

# region: Path
# ----
# Path
# ----

# Homebrew
# https://brew.sh/
# (Homebrew must come first so that other programs can enter the PATH.)
if [[ "$(uname)" == "Darwin" ]]; then
  if [[ ! -s "/opt/homebrew/bin/brew" ]]; then
    echo "Error: On macOS, these Bash configs require that you have Homebrew package manager installed. Run: /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"" >&2
    return 1
  fi

  eval "$(/opt/homebrew/bin/brew shellenv)"

  if ! command -v gsed &> /dev/null; then
    echo "Error: On macOS, these Bash configs require the GNU version of sed to be installed (because the BSD version is very old). Run: brew install gnu-sed" >&2
    return 1
  fi

  alias sed="gsed"
fi

# Add browsers to the path, which is necessary for the GitHub CLI.
if ! command -v chrome &> /dev/null && [[ -s "/c/Program Files/Google/Chrome/Application/chrome.exe" ]]; then
  export PATH="$PATH:/c/Program Files/Google/Chrome/Application"
fi
if ! command -v chrome &> /dev/null && [[ -s "$HOME/AppData/Local/Google/Chrome/Application/chrome.exe" ]]; then
  export PATH="$PATH:$HOME/AppData/Local/Google/Chrome/Application"
fi
if ! command -v chrome &> /dev/null && command -v google-chrome &> /dev/null; then
  alias chrome="google-chrome"
fi
if ! command -v msedge &> /dev/null && [[ -s "/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe" ]]; then
  export PATH="$PATH:/c/Program Files (x86)/Microsoft/Edge/Application"
fi
if ! command -v msedge &> /dev/null && command -v microsoft-edge &> /dev/null; then
  alias msedge="microsoft-edge"
fi

# bun
# https://bun.com/
append-path "$HOME/.bun/bin"

# Claude Code
# https://www.claude.com/product/claude-code
append-path "$HOME/.local/bin"

# fnm
# https://github.com/Schniz/fnm
append-path "$HOME/AppData/Local/Microsoft/WinGet/Packages/Schniz.fnm_Microsoft.Winget.Source_8wekyb3d8bbwe"
append-path "$HOME/.local/share/fnm"

# gitleaks
append-path "$HOME/OneDrive - LogixHealth Inc/Documents/Programs/gitleaks/gitleaks_8.28.0_windows_x64"

# GnuWin32
append-path "/c/Program Files (x86)/GnuWin32/bin"

# Node.js (through fnm)
if command -v fnm &> /dev/null && ! command -v node &> /dev/null; then
  eval "$(fnm env --shell bash)"
fi

# PostgreSQL
# e.g. /c/Program Files/PostgreSQL/18/bin
PG_PATH=$(find "/c/Program Files/PostgreSQL" -maxdepth 2 -type d -path "*/[0-9]*/bin" 2> /dev/null | sort --version-sort | tail -n 1)
if [[ -n "$PG_PATH" ]]; then
  append-path "$PG_PATH"
fi

# Python
# e.g. $HOME/AppData/Local/Python/pythoncore-3.14-64/Scripts
PYTHON_PATH_WINDOWS=$(find "$HOME/AppData/Local/Python" -maxdepth 2 -type d -path "*/pythoncore-*/Scripts" 2> /dev/null | sort --version-sort | tail -n 1)
if [[ -n "$PYTHON_PATH_WINDOWS" ]]; then
  append-path "$PYTHON_PATH_WINDOWS"
fi
# e.g. $HOME/Library/Python/3.9/bin
PYTHON_PATH_MACOS=$(find "$HOME/Library/Python" -maxdepth 2 -type d -path "*/bin" 2> /dev/null | sort --version-sort | tail -n 1)
if [[ -n "$PYTHON_PATH_MACOS" ]]; then
  append-path "$PYTHON_PATH_MACOS"
fi

# terragrunt
append-path "$HOME/OneDrive - LogixHealth Inc/Documents/Programs/terragrunt"

# endregion

# region: Other Environment Variables
# ---------------------------
# Other Environment Variables
# ---------------------------

# Load secret environment variables that cannot be committed to Git.
if [[ -s "$HOME/.env" ]]; then
  # shellcheck source=/dev/null
  source "$HOME/.env"
fi

# Fix self-signed certs for LogixHealth.
if [[ -s "/usr/local/share/ca-certificates/BEDROOTCA001.crt" ]]; then
  export COMPANY_CERT_PATH="/usr/local/share/ca-certificates/BEDROOTCA001.crt"
elif [[ -s "/c/tls/BEDROOTCA001.crt" ]]; then
  export COMPANY_CERT_PATH="/c/tls/BEDROOTCA001.crt"
elif [[ -s "/c/_IT/tls/BEDROOTCA001.crt" ]]; then
  export COMPANY_CERT_PATH="/c/_IT/tls/BEDROOTCA001.crt"
fi
if [[ -n "${COMPANY_CERT_PATH-}" ]]; then
  export NODE_EXTRA_CA_CERTS="$COMPANY_CERT_PATH"
  export CURL_CA_BUNDLE="$COMPANY_CERT_PATH"
fi
if [[ -s "/c/Program Files/Microsoft SDKs/Azure/CLI2/lib/site-packages/certifi/cacert.pem" ]]; then
  export REQUESTS_CA_BUNDLE="/c/Program Files/Microsoft SDKs/Azure/CLI2/lib/site-packages/certifi/cacert.pem"
elif [[ -s "/c/Program Files (x86)/Microsoft SDKs/Azure/CLI2/lib/site-packages/certifi/cacert.pem" ]]; then
  export REQUESTS_CA_BUNDLE="/c/Program Files (x86)/Microsoft SDKs/Azure/CLI2/lib/site-packages/certifi/cacert.pem"
elif [[ -s "/opt/az/lib/python3.13/site-packages/certifi/cacert.pem" ]]; then
  export REQUESTS_CA_BUNDLE="/opt/az/lib/python3.13/site-packages/certifi/cacert.pem"
fi
add-logix-cert-to-requests-ca-bundle

# Get the username in an operating system agnostic way.
if [[ -n "$USER" ]]; then # macOS/Linux
  export OS_USERNAME="$USER"
elif [[ -n "$USERNAME" ]]; then # Windows
  export OS_USERNAME="$USERNAME"
else
  echo "Failed to derive the operating system username." >&2
fi

# endregion

# region: Terminal Settings
# --------
# Terminal Settings
# --------

# Make writing to Bash command history immediate:
# https://askubuntu.com/questions/67283/is-it-possible-to-make-writing-to-bash-history-immediate
# This fixes the bug where closing one terminal window will remove the command history that was
# written by other terminal windows.
shopt -s histappend # This is "off" by default.
PROMPT_COMMAND="history -a; $PROMPT_COMMAND"

# Only modify other terminal settings if the shell is interactive.
if [[ $- == *i* ]]; then
  # Prevent "Last login: Mon Jan  1 12:00:00 on ttys000" from appearing on macOS. (Unfortunately, this
  # will only take effect on the next shell.)
  touch "$HOME/.hushlogin"

  # Emulate the Git Bash for Windows prompt on non-Windows platforms.
  if ! command -v __git_ps1 &> /dev/null; then
    GIT_SH_PROMPT_PATH_MACOS="/Library/Developer/CommandLineTools/usr/share/git-core/git-prompt.sh"
    GIT_SH_PROMPT_PATH_UBUNTU="/usr/lib/git-core/git-sh-prompt"
    if [[ -s "$GIT_SH_PROMPT_PATH_MACOS" ]]; then
      # shellcheck source=/dev/null
      source "$GIT_SH_PROMPT_PATH_MACOS"
    elif [[ -s "$GIT_SH_PROMPT_PATH_UBUNTU" ]]; then
      # shellcheck source=/dev/null
      source "$GIT_SH_PROMPT_PATH_UBUNTU"
    else
      echo "Error: Cannot find the \"__git_ps1\" function declared." >&2
      return 1
    fi
  fi

  if [[ -s "/etc/os-release" ]]; then
    # shellcheck source=/dev/null
    source /etc/os-release
  fi

  if [[ "$ID" == "ubuntu" ]] || [[ "$(uname)" == "Darwin" ]]; then
    # We copy the prompt from Git Bash for Windows:
    # https://github.com/git-for-windows/build-extra/blob/main/git-extra/git-prompt.sh
    PS1='\[\033]0;$TITLEPREFIX:$PWD\007\]' # set window title
    PS1="$PS1"'\n'                         # new line
    PS1="$PS1"'\[\033[32m\]'               # change to green
    PS1="$PS1"'\u@\h '                     # user@host<space>
    PS1="$PS1"'\[\033[35m\]'               # change to purple
    PS1="$PS1"'$MSYSTEM '                  # show MSYSTEM
    PS1="$PS1"'\[\033[33m\]'               # change to brownish yellow
    PS1="$PS1"'\w'                         # current working directory
    GIT_EXEC_PATH="$(git --exec-path 2> /dev/null)"
    COMPLETION_PATH="${GIT_EXEC_PATH%/libexec/git-core}"
    COMPLETION_PATH="${COMPLETION_PATH%/lib/git-core}"
    COMPLETION_PATH="$COMPLETION_PATH/share/git/completion"
    PS1="$PS1"'\[\033[36m\]' # change color to cyan
    PS1="$PS1"'`__git_ps1`'  # bash function
    PS1="$PS1"'\[\033[0m\]'  # change color
    PS1="$PS1"'\n'           # new line
    PS1="$PS1"'$ '           # prompt: always $
  fi

  # bun auto-complete for e.g. "bun run"
  # TODO: Does not work on my work computer.
  # if command -v bun &> /dev/null; then
  #   BUN_COMPLETIONS_PATH="$HOME/.bun/_bun"
  #   bun completions > "$BUN_COMPLETIONS_PATH"
  #   if [[ "$(uname)" == "Darwin" ]]; then
  #     # We modify the output from "bun completions" to work around this bug:
  #     # https://github.com/oven-sh/bun/issues/24847
  #     sed --in-place "s/local re_prev_script=/return; local re_prev_script=/" "$BUN_COMPLETIONS_PATH"
  #   fi
  #   # shellcheck source=/dev/null
  #   source "$BUN_COMPLETIONS_PATH"
  # fi

  # npm auto-complete for e.g. "npm run"
  # TODO: Commented out since it is too expensive.
  #if command -v npm &> /dev/null; then
  #  eval "$(npm completion)"
  #fi

  # zoxide (a better cd)
  # https://github.com/ajeetdsouza/zoxide
  if command -v zoxide &> /dev/null; then
    # We can use "zoxide init bash --cmd cd" to replace the "cd" command, but we do not need to do
    # this because we overwrite the "cd" command anyway.
    eval "$(zoxide init bash)"

    # Overwrite the "zi" command so that it functions similar to our custom "cd" command.
    zi() {
      __zoxide_zi "$@" && print-files-and-branches
    }
  fi

  # fzf (for fuzzy matching file paths)
  # https://github.com/junegunn/fzf
  if command -v fzf &> /dev/null; then
    eval "$(fzf --bash)"

    # https://github.com/junegunn/fzf?tab=readme-ov-file#advanced-topics
    # "--scheme=path" - Optimize the scoring for file paths.
    export FZF_COMPLETION_OPTS="--scheme=path"

    # Change fzf's "Alt + C" hotkey to use zoxide, if available.
    if command -v zi &> /dev/null; then
      bind '"\ec": "zi\n"'
    fi
  fi
fi

# endregion

# region: Git Settings
# ------------
# Git Settings
# ------------

# https://git-scm.com/docs/git-config/#Documentation/git-config.txt-coreautocrlf
# Default value: input
# Explicitly setting it to false prevents Git from changing line endings at any point, which can
# prevent issues when Windows users collaborate with MacOS/Linus users.
git config --global core.autocrlf false

# https://git-scm.com/docs/git-config/#Documentation/git-config.txt-coreignoreCase
# Default value: false (on Linux machines) or true (on Windows machines)
# Explicitly setting it to false can prevent problems with interop between Linux & Windows.
git config --global core.ignorecase false

# https://git-scm.com/docs/git-config/#Documentation/git-config.txt-diffcolorMoved
# Default value: false
# Setting zebra can make git diffs easier to read by having a different color for moved lines.
git config --global diff.colorMoved zebra

# https://git-scm.com/docs/git-config/#Documentation/git-config.txt-fetchprune
# Default value: false
# Automatically remove any remote-tracking references that no longer exist on the remote.
git config --global fetch.prune true

# https://git-scm.com/docs/git-config/#Documentation/git-config.txt-fetchpruneTags
# Default value: false
# Automatically remove any tags that no longer exist on the remote.
git config --global fetch.pruneTags true

# https://git-scm.com/docs/git-config/#Documentation/git-config.txt-pullrebase
# Default value: false
# Setting this prevents spurious merge commits.
git config --global pull.rebase true

# https://git-scm.com/docs/git-config/#Documentation/git-config.txt-pushautoSetupRemote
# Default value: false
# Setting this automates having "git pull" and "git push" work properly after setting up a new
# branch.
git config --global push.autoSetupRemote true

if [[ "$OS_USERNAME" == "james" || "$OS_USERNAME" == "jnesta" ]]; then
  git config --global user.name "Zamiell"
  git config --global user.email "5511220+Zamiell@users.noreply.github.com"
fi

# endregion

# region: Other Application Settings
# --------------------------
# Other Application Settings
# --------------------------

# ssh
mkdir -p "$HOME/.ssh" # The directory has to exist for the "ssh-keygen" command to work.
if ! ssh-keygen -F github.com &> /dev/null; then
  # Install the public key for "github.com".
  ssh-keyscan github.com >> "$HOME/.ssh/known_hosts" 2> /dev/null
fi

# npm
if command -v npm &> /dev/null; then
  NPM_CONFIG_PATH="$HOME/.npmrc"
  if [[ ! -s "$NPM_CONFIG_PATH" ]]; then
    touch "$NPM_CONFIG_PATH"
  fi

  if ! grep --quiet "save-exact=true" "$NPM_CONFIG_PATH"; then
    npm config set save-exact=true
  fi

  if [[ -n "$NODE_AUTH_TOKEN" ]]; then
    sed --in-place "/registry.npmjs.org/d" "$HOME/.npmrc"
    echo "//registry.npmjs.org/:_authToken=$NODE_AUTH_TOKEN" >> "$HOME/.npmrc"
  fi
fi

# endregion

# region: Miscellaneous Commands
# ----------------------
# Miscellaneous Commands
# ----------------------

# Opens the Azure DevOps URL for the "History" tab of the corresponding file.
azdo-history() (
  set -euo pipefail # Exit on errors and undefined variables.

  if [[ -z "${1:-}" ]]; then
    echo "Error: The file path is required. Usage: ${FUNCNAME[0]} <file_path>" >&2
    return 1
  fi
  local file_path="$1"

  local repo_root
  repo_root=$(git -C "$(dirname "$file_path")" rev-parse --show-toplevel)

  if command -v cygpath &> /dev/null; then
    file_path=$(cygpath --unix "$file_path")
    repo_root=$(cygpath --unix "$repo_root")
  fi

  local relative_path
  relative_path=$(realpath --relative-to="$repo_root" "$file_path")

  read -r host organization project repository <<< "$(get-git-remote-details "$repo_root")"
  if [[ "$host" != "azure-devops-server" ]]; then
    echo "Error: This command can only be used in a repository hosted on Azure DevOps server." >&2
    return 1
  fi

  # e.g. https://azuredevops.logixhealth.com/LogixHealth/Infrastructure/_git/infrastructure?path=/infrastructure.code-workspace&_a=history
  o "https://azuredevops.logixhealth.com/$organization/$project/_git/$repository?path=/$relative_path&_a=history"
)

# "bwl" is short for "bw login --apikey". (This is the BitWarden CLI.)
alias bwl="bw login --apikey"

# Only create the "cd" alias if the shell is interactive.
if [[ $- == *i* ]]; then
  # We have to use braces instead of parenthesis here.
  cd() {
    if command -v z &> /dev/null; then
      # Use "zoxide" if it is available.
      z "$@" && print-files-and-branches
    else
      builtin cd "$@" && print-files-and-branches
    fi
  }
fi

# "cdg" stands for "change directory git", which will change the working directory to the root of
# the current git repository. If used in a directory that is not part of a Git repository, it will
# throw an error.
cdg() {
  assert-in-git-repository

  local repo_root
  repo_root=$(git rev-parse --show-toplevel 2> /dev/null)
  if [[ -z "$repo_root" ]]; then
    echo "Error: Failed to get the root of the current git repository." >&2
    return 1
  fi

  cd "$repo_root"
}

# Turn off Claude Code prompts.
alias claude="claude --dangerously-skip-permissions"

# "csf" is short for "CSpell fix", which will invoke "cspell-check-unused-words --fix".
csf() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert-in-git-repository
  exec-package cspell-check-unused-words --fix

  if [[ -n "$(git status --porcelain)" ]]; then
    gc "chore: remove unused words from the CSpell configuration file"
  fi
)

alias full-path="readlink -f"

# Get our ".env" file from BitWarden. (We must sync first because the BitWarden CLI uses a local
# copy of the vault.)
alias get-env='bw sync && bw get notes .env > $HOME/.env'

# Turn off Gemini Code Assist prompts.
alias gemini="gemini --yolo"

get-ssh-keys() (
  set -euo pipefail # Exit on errors and undefined variables.

  mkdir -p "$HOME/.ssh"
  bw sync
  # The secret is "id_ed25519.key" instead of "id_ed25519" because otherwise, BitWarden will
  # complain that "More than one result was found".
  bw get notes id_ed25519.key > "$HOME/.ssh/id_ed25519"
  chmod 600 "$HOME/.ssh/id_ed25519"
  bw get notes id_ed25519.pub > "$HOME/.ssh/id_ed25519.pub"
)

# "kb" is short for "kubernetes build".
alias kb='(builtin cd $REPOSITORIES_DIR/infrastructure/3_Applications/kubernetes && npm run build)'

# A better "ll" alias that shows human-readable file sizes.
# (macOS does not support any of the long-form flags, so we use the short ones instead.)
# - "-a" is short for "--all", which shows hidden files.
# - "-h" is short for "--human-readable", which converts bytes to kilobytes and so on.
# - "-F" is short for "--classify", which displays extra characters to signify the file type.
# - "--color=auto" makes Ubuntu have the same colors that Git Bash for Windows does.
alias ll="ls -a -h -l -F --color=auto"

# Ask an LLM a question from the terminal.
llm() (
  set -euo pipefail # Exit on errors and undefined variables.

  if [[ $# -eq 0 ]]; then
    echo "Error: The prompt is required. Usage: ${FUNCNAME[0]} <prompt>" >&2
    return 1
  fi
  local prompt="$*"

  local system_prompt="You are being asked a question inside of a terminal. Be fairly brief in your response. For example, if you are being asked what the command is for something, format your response as just the command and a 1-2 sentence description."

  get-llm-output "$system_prompt" "$prompt"
)

# "n" is short for "nuke".
alias n="bunx complete-cli@latest nuke"

# "o" is short for "open", to open a URL in a browser.
o() (
  set -euo pipefail # Exit on errors and undefined variables.

  if [[ -z "${1:-}" ]]; then
    echo "Error: URL is required. Usage: ${FUNCNAME[0]} <url>" >&2
    return 1
  fi
  local url="$1"

  if [[ "$url" == *"logixhealth"* ]] && command -v msedge &> /dev/null; then
    # We remove the output to prevent the "Opening in existing browser session." text from appearing
    # on Linux.
    msedge "$url" > /dev/null
    return
  fi

  if command -v chrome &> /dev/null; then
    # We remove the output to prevent the "Opening in existing browser session." text from appearing
    # on Linux.
    chrome "$url" > /dev/null
    return
  fi

  # macOS and Linux have the "open" command:
  # https://ss64.com/mac/open.html
  if command -v open &> /dev/null; then
    # We remove the output to prevent the "Opening in existing browser session." text from appearing
    # on Linux.
    open "$url" > /dev/null
    return
  fi

  echo "Git commit URL is at:"
  echo "$url"
)

# No global pip command is included on Windows:
# https://peps.python.org/pep-0773/#global-pip-command
if command -v python &> /dev/null && ! command -v pip &> /dev/null; then
  alias pip="python -m pip"
fi

put-env() (
  set -euo pipefail # Exit on errors and undefined variables.

  if [[ -z "$BW_SESSION" ]]; then
    echo "Error: The \"BW_SESSION\" environment variable is not set. Run: bw unlock" >&2
    return 1
  fi

  local env_path="$HOME/.env"
  if [[ ! -s "$env_path" ]]; then
    echo "Error: The \"$env_path\" file is missing or empty." >&2
    return 1
  fi

  assert-jq-installed

  bw sync

  local bw_item
  bw_item=$(bw get item .env)
  if [[ -z "$bw_item" ]]; then
    echo "Error: Could not find a Bitwarden item named: .env"
    return 1
  fi

  local bw_item_id
  bw_item_id=$(jq --raw-output .id <<< "$bw_item")
  if [[ -z "$bw_item_id" ]]; then
    echo "Error: Failed to parse the \"id\" key from the Bitwarden item."
    return 1
  fi

  local bw_item_updated
  bw_item_updated=$(jq --arg notes "$(cat "$env_path")" '.notes = $notes' <<< "$bw_item")

  # We get rid of the output to prevent passwords from appearing on the screen.
  echo "$bw_item_updated" | bw encode | bw edit item "$bw_item_id" > /dev/null
  echo "Successfully uploaded \"$env_path\" to Bitwarden."
)

# "r" is short for switching to the repositories directory.
if [[ -d "$HOME/Repositories" ]]; then # Windows / macOS
  REPOSITORIES_DIR="$HOME/Repositories"
elif [[ -d "$HOME/repositories" ]]; then # Linux
  REPOSITORIES_DIR="$HOME/repositories"
elif [[ -d "/c/Repositories" ]]; then # Windows C drive
  REPOSITORIES_DIR="/c/Repositories"
elif [[ -d "/d/Repositories" ]]; then # Windows D drive
  REPOSITORIES_DIR="/d/Repositories"
fi
if [[ -n "$REPOSITORIES_DIR" ]]; then
  export REPOSITORIES_DIR
  alias cdr='builtin cd $REPOSITORIES_DIR'

  # By default, it is useful for shells to open in the repositories directory instead of the home
  # directory. (But only do this if the shell is interactive and we are starting in the home
  # directory.)
  if [[ $- == *i* ]] && [[ "$PWD" == "$HOME" ]]; then
    builtin cd "$REPOSITORIES_DIR"
  fi
fi

# Alias "start" to "open" on macOS and "xdg-open" on Linux. ("start" is a Windows-only command to
# open explorer at the given path.)
start() (
  set -euo pipefail # Exit on errors and undefined variables.

  if is-git-bash; then
    # We must use "command" to invoke "start" to prevent an infinite loop.
    command start "$@"
  elif [[ "$(uname)" == "Darwin" ]]; then
    open "$@"
  else
    xdg-open "$@"
  fi
)

# "tpr" is short for "test-pr".
tpr() (
  builtin cd "$REPOSITORIES_DIR/infrastructure/3_Applications/containers/logix-ci-cd-tasks"
  bun run test-pr "$@"
)

# Establishes a connection to the LogixHealth VPN in the background. (This is intended to be used on
# Linux devices.)
vpn() (
  set -euo pipefail # Exit on errors and undefined variables.

  MICROSOFT_EDGE_PATH="/opt/microsoft/msedge/msedge"
  if [[ ! -s "$MICROSOFT_EDGE_PATH" ]]; then
    echo "Error: Microsoft Edge must be installed at: $MICROSOFT_EDGE_PATH" >&2
    return 1
  fi

  sudo killall gpclient
  sudo nohup gpclient connect lhvpn.logixhealth.com --browser "$MICROSOFT_EDGE_PATH" &
)

# endregion

# region: kubectl Commands
# ----------------
# kubectl Commands
# ----------------

alias k="kubectl"
alias kdd="kubectl describe deployment"
alias kdp="kubectl describe pod"
alias kds="kubectl describe service"
alias kgd="kubectl get deployment"
alias kgp="kubectl get pod"

# endregion

# region: npm Commands
# ------------
# npm Commands
# ------------

exec-package() (
  set -euo pipefail # Exit on errors and undefined variables.

  if [[ -z "${1-}" ]]; then
    echo "Error: The package name is required. Usage: ${FUNCNAME[0]} <package_name>" >&2
    return 1
  fi

  local package_manager
  package_manager="$(get-package-manager)"

  local exec_command
  case $package_manager in
    npm)
      exec_command="npx"
      ;;
    yarn)
      exec_command="npx"
      ;;
    pnpm)
      exec_command="pnpm exec"
      ;;
    bun)
      exec_command="bunx"
      ;;
    *)
      echo "Error: Not able to determine the exec command for the package manager of: $package_manager" >&2
      return 1
      ;;
  esac

  "$exec_command" "$@"
)

get-package-manager() (
  set -euo pipefail # Exit on errors and undefined variables.

  local current_dir="$PWD"

  # Search upward through directories, looking for package lock files.
  while [[ "$current_dir" != "/" ]]; do
    if [[ -s "$current_dir/package-lock.json" ]]; then
      echo "npm"
      return
    fi

    if [[ -s "$current_dir/yarn.lock" ]]; then
      echo "yarn"
      return
    fi

    if [[ -s "$current_dir/pnpm-lock.yaml" ]]; then
      echo "pnpm"
      return
    fi

    if [[ -s "$current_dir/bun.lock" ]]; then
      echo "bun"
      return
    fi

    current_dir="$(dirname "$current_dir")"
  done

  # If no lock file was found, default to npm.
  echo "npm"
)

run-package-script() (
  set -euo pipefail # Exit on errors and undefined variables.

  if [[ -z "${1-}" ]]; then
    echo "Error: The script name is required. Usage: ${FUNCNAME[0]} <script_name>" >&2
    return 1
  fi

  local package_manager
  package_manager="$(get-package-manager)"
  "$package_manager" run "$@"
)

alias b="run-package-script build"
alias d="run-package-script dev"
alias l="run-package-script lint"
alias la="run-package-script lint-all"
alias p="run-package-script publish"
alias s="run-package-script start"
alias t="run-package-script test"
alias u="run-package-script update || exec-package complete-cli@latest update"

# endregion

# region: Git Commands
# ------------
# Git Commands
# ------------

# "ga" is short for "git add".
alias ga="git add"

# "gaa" is short for "git add --all".
alias gaa="git add --all"

# - "gb" is short for creating a new git branch, which is a common coding task.
# - If the remote repository is not GitHub, this will make the branch according to the LogixHealth
#   branch naming convention.
# - Doing a push is important after creating a new branch because it prevents subsequent "git pull"
#   calls from failing.
# - You can use the "-n" or "--no-convention" flag to omit the LogixHealth naming convention.
gb() (
  set -euo pipefail # Exit on errors and undefined variables.

  local use_logixhealth_convention="true"
  local positional_args=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -n | --no-convention)
        use_logixhealth_convention="false"
        shift
        ;;
      *)
        positional_args+=("$1")
        shift
        ;;
    esac
  done
  set -- "${positional_args[@]}" # Restore positional parameters.

  assert-in-git-repository

  local new_branch_name="misc"
  if [[ -n "${1:-}" ]]; then
    new_branch_name="$1"
  fi

  if [[ "$use_logixhealth_convention" == "true" ]] && ! is-github-repository; then
    local application_name="misc"
    if [[ -n "${2:-}" ]]; then
      application_name="$2"
    fi

    new_branch_name="feature/$application_name/$OS_USERNAME/$new_branch_name"
  fi

  if [[ -n "$(git status --porcelain)" ]]; then
    echo "The repository is not clean. Stashing all of your existing changes."
    git stash push --message "Auto-stash before creating a new git branch"
  fi

  local main_branch_name
  main_branch_name=$(get-main-branch-name)

  if [[ "$(git branch --show-current)" != "$main_branch_name" ]]; then
    git switch "$main_branch_name"
  fi

  if git remote get-url upstream &> /dev/null; then
    gh-sync
  else
    git pull --rebase
  fi

  git switch --create "$new_branch_name"
  git push

  if [[ $(git stash list | wc -l) -gt 0 ]]; then
    echo "A previous git stash exists. Applying it to this new branch."
    git stash pop
  fi

  echo
  gbl
)

# "gb_" is an alias for "gb --no-convention".
alias gb_="gb --no-convention"

# "gbc" is short for "git branch clean", which will remove all local branches that do not exist on
# the remote repository.
# https://stackoverflow.com/questions/7726949/remove-tracking-branches-no-longer-on-remote
gbc() (
  set -euo pipefail # Exit on errors and undefined variables.

  local skip_fetch=false
  for arg in "$@"; do
    if [[ "$arg" == "--skip-fetch" ]]; then
      skip_fetch=true
    fi
  done

  assert-in-git-repository

  local main_branch_name
  main_branch_name=$(get-main-branch-name)

  if [[ "$(git branch --show-current)" != "$main_branch_name" ]]; then
    git switch "$main_branch_name"
  fi

  if [[ "$skip_fetch" == false ]]; then
    git fetch --prune --quiet
  fi

  git branch -vv | awk "/: gone]/{print \$1}" | xargs --no-run-if-empty git branch --delete --force

  # Additionally, we want to delete branches from merged pull requests.
  if git remote get-url upstream &> /dev/null; then
    gh-clean
  fi

  echo
  gbl
)

# "gbd" is short for "git branch delete", which will delete the branch both locally and remotely.
gbd() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert-in-git-repository

  local branch_name_or_number=""
  local only_local="false"

  for arg in "$@"; do
    if [[ "$arg" == "--only-local" ]]; then
      only_local="true"
    else
      branch_name_or_number="$arg"
    fi
  done

  if [[ -z "$branch_name_or_number" ]]; then
    echo "Error: Branch name or number is required. Usage: ${FUNCNAME[0]} <branch-name-or-number> [--only-local]" >&2
    return 1
  fi

  local branch_name
  branch_name=$(get-branch-name-from-number "$branch_name_or_number")

  if [[ "$branch_name" == "main" ]] || [[ "$branch_name" == "master" ]]; then
    echo "Error: You cannot use this command to delete the \"$branch_name\" branch. Are you sure you want to delete that?" >&2
    return 1
  fi

  local current_branch_name
  current_branch_name=$(git branch --show-current)
  if [[ "$branch_name" == "$current_branch_name" ]]; then
    echo "Error: You are deleting branch \"$branch_name\", but that is the branch that you are currently on. Switch to another branch first." >&2
    return 1
  fi

  # Delete the branch locally.
  if git show-ref --verify --quiet "refs/heads/$branch_name"; then
    git branch --delete --force "$branch_name"
    echo "Deleted branch \"$branch_name\" locally."
  else
    echo "Warning: Branch \"$branch_name\" does not exist locally."
  fi

  # Delete the branch remotely.
  if [[ "$only_local" == "false" ]]; then
    if git ls-remote --heads origin "$branch_name" | grep --quiet .; then
      git push origin ":$branch_name"
      echo "Deleted branch \"$branch_name\" remotely."
    else
      echo "Warning: Branch \"$branch_name\" does not exist on remote origin."
    fi
  fi

  echo
  gbl
)

# "gbdl" is short for "git branch delete local", which will delete the branch locally (and not
# remotely).
gbdl() (
  gbd "$1" --only-local
)

# "gbl" is short for "git branch list". ("gb" is already taken by another command.)
gbl() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert-in-git-repository

  local local_branches
  # We need to use "lstrip" instead of "short" since the latter does not work properly with branches
  # from "gh pr checkout".
  local_branches=$(git branch --format="%(refname:lstrip=2)" | sort)
  local current_branch
  current_branch=$(git branch --show-current)

  local GREEN_CODE='\033[32m'
  local RESET_CODE='\033[0m'

  local total_lines
  total_lines=$(echo "$local_branches" | wc -l | tr -d '[:space:]')
  local width=${#total_lines}

  echo "Current git branches:"

  local count=1
  while IFS= read -r branch; do
    if [[ "$branch" == "$current_branch" ]]; then
      printf "${GREEN_CODE}* %*d - %s${RESET_CODE}\n" "$width" "$count" "$branch"
    else
      printf "  %*d - %s\n" "$width" "$count" "$branch"
    fi

    ((count++))
  done <<< "$local_branches"
)

# "gblr" is short for "git branch list remote".
gblr() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert-in-git-repository

  git fetch --prune --quiet

  local remote_branches
  remote_branches=$(git branch --format="%(refname:lstrip=2)" --remotes | grep --invert-match --line-regexp "origin" | grep --invert-match "^origin/" | sort)

  echo "Remote git branches:"

  local count=1
  while IFS= read -r branch; do
    echo "  ${count} - ${branch}"
    ((count++))
  done <<< "$remote_branches"
)

# "gbr" is short for "git branch rename".
# - You can use the "-n" or "--no-convention" flag to omit the LogixHealth naming convention.
gbr() (
  set -euo pipefail # Exit on errors and undefined variables.

  local use_logixhealth_convention="true"
  local positional_args=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -n | --no-convention)
        use_logixhealth_convention="false"
        shift
        ;;
      *)
        positional_args+=("$1")
        shift
        ;;
    esac
  done
  set -- "${positional_args[@]}" # Restore positional parameters.

  assert-in-git-repository

  local old_branch_name
  old_branch_name=$(git branch --show-current) # e.g. "feature/misc/alice/fix-bug-1"

  local new_branch_name
  if [[ "$use_logixhealth_convention" == "true" ]]; then
    if [[ -z "${1:-}" ]]; then
      echo "Error: Application name is required. Usage: ${FUNCNAME[0]} <application-name> [description]" >&2
      return 1
    fi
    local new_app_name="$1"

    IFS='/' read -ra branch_parts <<< "$old_branch_name"
    if [[ ${#branch_parts[@]} -ne 4 ]]; then
      echo "Error: Branch name must have exactly 4 parts separated by a forward slash. The current branch name is: $old_branch_name" >&2
      return 1
    fi

    local branch_type="${branch_parts[0]}"     # e.g. "feature"
    local branch_username="${branch_parts[2]}" # e.g. "alice"
    local old_description="${branch_parts[3]}" # e.g. "fix-bug-1"
    local new_description="$old_description"
    if [[ -n "${2:-}" ]]; then
      new_description="$2"
    fi

    new_branch_name="$branch_type/$new_app_name/$branch_username/$new_description"
  else
    if [[ -z "${1:-}" ]]; then
      echo "Error: Branch name is required. Usage: ${FUNCNAME[0]} <branch-name>" >&2
      return 1
    fi
    new_branch_name="$1"
  fi

  echo "Old branch name: $old_branch_name"
  echo "New branch name: $new_branch_name"

  git switch --create "$new_branch_name"
  git push
  git push origin ":$old_branch_name"            # Delete the old branch on the remote.
  git branch --delete --force "$old_branch_name" # Delete the old branch locally.
)

# "gbr_" is an alias for "gbr --no-convention".
alias gbr_="gbr --no-convention"

# "gbs" is short for "git branch squash", which squash all commits on the branch.
gbs() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert-in-git-repository
  assert-feature-branch

  local branch_name
  branch_name=$(git branch --show-current)

  local merge_base
  merge_base=$(get-merge-base)

  local num_branch_commits
  num_branch_commits=$(git rev-list --count "$merge_base..$branch_name")

  if [[ "$num_branch_commits" -eq 1 ]]; then
    echo "There is only 1 commit on this branch, so no squashing is needed."
    return
  fi

  git reset --soft "HEAD~$num_branch_commits"
  git commit --message "chore: squashed $num_branch_commits commits"
  git push --force-with-lease
)

# "gc" is short for "git commit", which will perform all the steps involved in making a new commit
# with all unstaged changes. The arguments that are provided will be the commit message. If no
# arguments are provided, then the script will attempt to find a suitable commit message.
gc() (
  set -euo pipefail # Exit on errors and undefined variables.

  local amend="false"
  local edit_commit_message="false"
  local commit_message_args=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --amend)
        amend="true"
        shift
        ;;
      --edit-commit-message)
        edit_commit_message="true"
        shift
        ;;
      *)
        commit_message_args+=("$1")
        shift
        ;;
    esac
  done

  local commit_message="${commit_message_args[*]}"

  assert-in-git-repository

  if [[ -z "$(git config user.name)" ]]; then
    echo "Error: Git user name not set. Run: git config --global user.name \"Your Name\"" >&2
    return 1
  fi

  if [[ -z "$(git config user.email)" ]]; then
    echo "Error: Git user email not set. Run: git config --global user.email you@example.com" >&2
    return 1
  fi

  local user_email
  user_email=$(git config user.email)
  if is-github-repository; then
    if [[ "$user_email" == *logixhealth.com ]]; then
      echo "Error: You are trying to commit to a GitHub repository with an email of \"$user_email\", which might be a mistake." >&2
      return 1
    fi
  else
    if [[ "$user_email" == *github.com || "$user_email" == *gmail.com ]]; then
      if [[ "$OS_USERNAME" == "james" || "$OS_USERNAME" == "jnesta" ]]; then
        git config user.name "James Nesta"
        git config user.email "jnesta@logixhealth.com"
      else
        echo "Error: You are trying to commit to an non-GitHub repository with an email of \"$user_email\", which might be a mistake." >&2
        return 1
      fi
    fi
  fi

  local branch_name
  branch_name=$(git branch --show-current)

  local repository_has_commits="false"
  if git rev-parse --verify HEAD &> /dev/null; then
    repository_has_commits="true"
  fi

  local has_upstream_config="false"
  if [[ -n "$(git config branch."$branch_name".merge)" ]]; then
    has_upstream_config="true"
  fi

  # Only check for the remote branch existing if:
  # 1) There are one or more commits. (For brand-new repositories, the remote branch will not yet
  #    exist.)
  # 2) This is not a repository from: gh pr checkout
  if [[ "$repository_has_commits" == "true" ]] && [[ "$has_upstream_config" == "false" ]]; then
    local remote_branch_info
    remote_branch_info=$(git ls-remote --heads origin "$branch_name")

    if [[ -z "$remote_branch_info" ]]; then
      echo "Error: The remote branch of \"$branch_name\" does not yet exist." >&2
      return 1
    fi
  fi

  if [[ "$amend" == "true" ]]; then
    # Validate that we are at the remote tip so that we do not accidentally blow away commits.
    git fetch origin "$branch_name" --prune --quiet
    local latest_commit_local
    latest_commit_local=$(git rev-parse HEAD)
    local latest_commit_remote
    latest_commit_remote=$(git rev-parse "origin/$branch_name")

    if [[ "$latest_commit_local" != "$latest_commit_remote" ]] && ! git merge-base --is-ancestor "$latest_commit_remote" HEAD; then
      echo "Error: Remote branch has commits are not present locally. Do a \"git pull\" first or use a different approach." >&2
      return 1
    fi
  fi

  git add --all

  # Validate that we have one or more new changes to commit. (But allow 0 change commits if we are
  # only editing the commit message.)
  if [[ "$edit_commit_message" == "false" ]] && git diff --cached --quiet; then
    echo "Error: There are no changes to commit."
    return 1
  fi

  if [[ "$amend" == "true" ]]; then
    if [[ "$edit_commit_message" == "true" ]]; then
      # "--amend" amends the previous commit instead of making a new commit.
      # "--allow-empty" allows amending the commit message without changing any files.
      git commit --amend --allow-empty
    else
      # "--amend" amends the previous commit instead of making a new commit.
      # "--no-edit" avoids prompting for a commit message and uses the default commit message.
      git commit --amend --no-edit
    fi

    # We do not need to "git pull" because we already verified above that we are on the remote tip.
    git push --force-with-lease
  else
    if [[ -n "$commit_message" ]]; then
      # A commit message was provided at the command-line. Spell check it using CSpell.
      if [[ -z "${NO_SPELL_CHECK-}" ]] && command -v bunx &> /dev/null; then
        {
          # https://cspell.org/docs/Configuration/document-settings#ignore
          echo "# cSpell:ignore $CSPELL_IGNORED_WORDS"
          echo "$commit_message"
        } | bunx cspell stdin --no-progress --no-summary
        # - "--no-progress" and "--no-summary" make it only output errors.
      fi
    else
      # A commit message was not provided at the command-line.
      if [[ -z "${GEMINI_API_KEY:-}" ]]; then
        commit_message="chore: update something"
      else
        echo "Getting the commit message from an LLM..."
        commit_message=$(get-llm-commit-message)
      fi
    fi

    git commit --message "$commit_message"

    if [[ "$repository_has_commits" == "true" ]]; then
      set-gh-remote
      git pull --rebase
    fi

    git push
  fi

  gcs
)

# "gca" is short for "git commit amend". This is similar to "gc", but it will amend the previous
# commit and add all unstaged files. Use this sparingly, since it will force push. By default, it
# will use the previous commit message, but you can use "gca edit" (or "gcam") to edit the commit
# message before pushing.
gca() (
  gc --amend
)

# "gcam" is short for "git commit amend message". This is similar to "gca", but it will also allow
# you to change the commit message.
gcam() (
  gc --amend --edit-commit-message
)

# "gcs" is short for "git commit show", which will open a browser to view the last commit.
gcs() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert-in-git-repository

  # e.g. "efe970b4d2d9c7a7023919ea677efce70222c201"
  local commit_sha1
  commit_sha1=$(git rev-parse HEAD)

  read -r host _2 _3 _4 <<< "$(get-git-remote-details)"

  local commit_url
  if [[ "$host" == "github" ]]; then
    read -r host author repository <<< "$(get-git-remote-details)"
    commit_url="https://github.com/$author/$repository/commit/$commit_sha1"
  elif [[ "$host" == "azure-devops-services" ]]; then
    read -r host organization project repository <<< "$(get-git-remote-details)"
    commit_url="https://dev.azure.com/$organization/$project/_git/$repository/commit/$commit_sha1"
  elif [[ "$host" == "azure-devops-server" ]]; then
    read -r host organization project repository <<< "$(get-git-remote-details)"
    commit_url="https://azuredevops.logixhealth.com/$organization/$project/_git/$repository/commit/$commit_sha1"
  else
    echo "Unknown git remote host: $host" >&2
    return 1
  fi

  o "$commit_url"
)

# "gcu" is short for "git commit undo", which will undo the last commit locally (but not on the
# remote). You can also provide a number argument to undo the last N commits.
gcu() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert-in-git-repository

  local num_commits=1
  if [[ -n "${1:-}" ]]; then
    if [[ "$1" =~ ^[0-9]+$ ]]; then
      num_commits="$1"
    else
      echo "Error: The argument of \"$1\" is not a number." >&2
      return 1
    fi
  fi

  git reset "HEAD~$num_commits" --soft
)

# "gd" is short for "git diff".
alias gd="git diff"

# "gl" is short for "git log".
alias gl="git log"

# "glg" is short for "git log --graph" with specific formatting.
alias glg="git log --graph --pretty=format:'%C(yellow)%h%Creset %C(cyan)%d%Creset %C(white)%s%Creset %C(green)(%an)%Creset%n%w(0,8,8)%b%Creset' --all --decorate"

# "gmc" is short for "git merge conflicts", which will show the files that need to be resolved
# before the merge/rebase/whatever can proceed.
alias gmc="git diff --name-only --diff-filter=U"

# "gmco" is short for "git merge conflicts open", which is similar to "gmc", but will open all of
# the files that need to be resolved in Visual Studio Code.
alias gmco="git diff --name-only --diff-filter=U | xargs code"

# "gp" is short for "git pull --rebase".
alias gp="git pull --rebase"

# "gpm" is short for "git pull mine", which will fetch all remote branches that start with
# "feature/misc/[username]/" and create local tracking branches for them if they do not already
# exist.
gpm() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert-in-git-repository

  git fetch origin --prune --quiet

  local prefix="feature/misc/$OS_USERNAME/"

  # We use "--list" to filter the branches directly via Git.
  local remote_branches
  remote_branches=$(git branch --remotes --format="%(refname:lstrip=2)" --list "origin/$prefix*")

  if [[ -z "$remote_branches" ]]; then
    return
  fi

  echo "$remote_branches" | while IFS= read -r remote_branch; do
    local local_branch="${remote_branch#origin/}"

    if git show-ref --verify --quiet "refs/heads/$local_branch"; then
      # Mimic the output of "git branch --track".
      echo "branch '$local_branch' also exists locally."
    else
      git branch --track "$local_branch" "$remote_branch"
    fi
  done
)

# "gpr" is short for "git pull request", to start a new pull request based on the current branch.
# The arguments that are provided will be the pull request title. If no arguments are provided, then
# the script will attempt to find a suitable pull request title.
gpr() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert-in-git-repository
  assert-feature-branch

  # After: host/org/project/repository and personal_access_token determination
  if ! azdo_pat_check; then
    return 1
  fi

  local branch_name
  branch_name=$(git branch --show-current)

  local main_branch_name
  main_branch_name=$(get-main-branch-name)

  local git_diff
  git_diff=$(git diff "$main_branch_name"...HEAD)

  if [[ -z "$git_diff" ]]; then
    echo "Error: There are no changes between this branch and the \"$main_branch_name\" branch." >&2
    return 1
  fi

  if is-github-repository; then
    gh pr create --fill-first --web
    return
  fi

  assert-jq-installed

  read -r host organization project repository <<< "$(get-git-remote-details)"
  if [[ "$host" != "azure-devops-server" ]] && [[ "$host" != "azure-devops-services" ]]; then
    echo "Error: The ${FUNCNAME[0]} command cannot be used with host: $host" >&2
    return 1
  fi

  # First, check for an existing pull request.
  local domain
  if [[ "$host" == "azure-devops-server" ]]; then
    domain="azuredevops.logixhealth.com"
  elif [[ "$host" == "azure-devops-services" ]]; then
    domain="dev.azure.com"
  fi
  local api_version="7.0"
  local azdo_project_url="https://$domain/$organization/$project"
  local azdo_api_url="$azdo_project_url/_apis/git/repositories/$repository/pullrequests?api-version=$api_version"
  local azdo_api_url_check="$azdo_api_url&searchCriteria.sourceRefName=refs/heads/$branch_name&searchCriteria.status=active"

  local personal_access_token
  if [[ "$host" == "azure-devops-server" ]]; then
    if [[ -z "${AZDO_PERSONAL_ACCESS_TOKEN_SERVER:-}" ]] && [[ -n "${AZDO_PERSONAL_ACCESS_TOKEN:-}" ]]; then
      AZDO_PERSONAL_ACCESS_TOKEN_SERVER="$AZDO_PERSONAL_ACCESS_TOKEN"
    fi

    if [[ -z "${AZDO_PERSONAL_ACCESS_TOKEN_SERVER:-}" ]]; then
      echo "Error: The \"AZDO_PERSONAL_ACCESS_TOKEN_SERVER\" environment variable is not set. (This is required to automatically open pull requests to Azure DevOps Server.)" >&2
      return 1
    fi

    personal_access_token="$AZDO_PERSONAL_ACCESS_TOKEN_SERVER"
  elif [[ "$host" == "azure-devops-services" ]]; then
    if [[ -z "${AZDO_PERSONAL_ACCESS_TOKEN_SERVICES:-}" ]] && [[ -n "${AZDO_PERSONAL_ACCESS_TOKEN:-}" ]]; then
      AZDO_PERSONAL_ACCESS_TOKEN_SERVICES="$AZDO_PERSONAL_ACCESS_TOKEN"
    fi

    if [[ -z "${AZDO_PERSONAL_ACCESS_TOKEN_SERVICES:-}" ]]; then
      echo "Error: The \"AZDO_PERSONAL_ACCESS_TOKEN_SERVICES\" environment variable is not set. (This is required to automatically open pull requests to Azure DevOps Services.)" >&2
      return 1
    fi

    personal_access_token="$AZDO_PERSONAL_ACCESS_TOKEN_SERVICES"
  fi

  local api_response_check
  api_response_check=$(
    curl \
      --silent \
      --fail \
      --show-error \
      --location \
      --user ":$personal_access_token" \
      "$azdo_api_url_check" || {
      local err="$?"
      echo "curl failed on URL: $azdo_api_url_check" >&2
      return "$err"
    }
  )

  local pull_request_count
  pull_request_count=$(echo "$api_response_check" | jq -r '.count')

  local azdo_pull_request_url_prefix="$azdo_project_url/_git/$repository/pullrequest"

  if [[ "$pull_request_count" != "0" ]]; then
    local existing_pull_request_id
    existing_pull_request_id=$(echo "$api_response_check" | jq -r '.value[0].pullRequestId')

    local existing_pull_request_url="$azdo_pull_request_url_prefix/$existing_pull_request_id"
    o "$existing_pull_request_url"

    echo "Pull request already exists: $existing_pull_request_url"
    return
  fi

  # Second, use the Azure DevOps API to open a new pull request.
  local pull_request_text
  if [[ $# -eq 0 ]]; then
    if [[ -z "${GEMINI_API_KEY:-}" ]]; then
      # If the user does not have an API key, use a generic pull request title and description.
      echo "Using the first commit description as the pull request title & description."
      pull_request_text=$(get-first-branch-commit-description)
    else
      if [[ $(get-num-commits-on-branch) == "1" ]]; then
        echo "Using the only commit description as the pull request title & description."
        pull_request_text=$(get-first-branch-commit-description)
      else
        echo "Getting the pull request title & description from an LLM..."
        pull_request_text=$(get-llm-pull-request-text)
      fi
    fi
  else
    pull_request_text="$*"

    # A pull request title was provided at the command-line. Spell check it using CSpell.
    if [[ -z "${NO_SPELL_CHECK-}" ]] && command -v bunx &> /dev/null; then
      {
        # https://cspell.org/docs/Configuration/document-settings#ignore
        echo "# cSpell:ignore $CSPELL_IGNORED_WORDS"
        echo "$pull_request_text"
      } | exec-package cspell stdin --no-progress --no-summary
      # - "--no-progress" and "--no-summary" make it only output errors.
    fi
  fi

  local pull_request_title
  pull_request_title=$(echo "$pull_request_text" | head -n 1)

  local pull_request_description
  pull_request_description=$(echo "$pull_request_text" | tail -n +2 | remove-leading-and-trailing-whitespace)
  if [[ -z "$pull_request_description" ]]; then
    pull_request_description="n/a"
  fi

  local json_payload
  json_payload=$(jq -n \
    --arg source "refs/heads/$branch_name" \
    --arg target "refs/heads/$main_branch_name" \
    --arg title "$pull_request_title" \
    --arg desc "$pull_request_description" \
    '{sourceRefName: $source, targetRefName: $target, title: $title, description: $desc}')

  local response_body
  response_body=$(mktemp)
  trap 'rm -f "$response_body"' EXIT

  curl \
    --silent \
    --fail \
    --show-error \
    --location \
    --output "$response_body" \
    --user ":$personal_access_token" \
    --header "Content-Type: application/json" \
    --data "$json_payload" \
    "$azdo_api_url" || {
    local err="$?"
    echo "curl failed on URL: $azdo_api_url" >&2
    echo "data was:"
    echo "$json_payload"
    return "$err"
  }

  # Finally, open the new pull request in a browser so that the user can confirm that everything
  # looks okay.
  local pull_request_id
  pull_request_id=$(jq -r '.pullRequestId' "$response_body")
  local pull_request_url="$azdo_pull_request_url_prefix/$pull_request_id"
  echo "Created pull request: $pull_request_url"
  o "$pull_request_url"
)

# "grb" is short for "git rebase".
alias grb="git rebase"

# "grba" is short for "git rebase --abort".
alias grba="git rebase --abort"

# "grbc" is short for "git rebase --continue". (It will automatically add all files for you.)
grbc() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert-in-git-repository

  git add --all
  git rebase --continue
  git push --force-with-lease
)

# "grbm" is short for "git rebase main".
grbm() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert-in-git-repository
  assert-feature-branch

  local main_branch_name
  main_branch_name=$(get-main-branch-name)

  git fetch origin "$main_branch_name" --prune --quiet
  git rebase "origin/$main_branch_name"
  git push --force-with-lease
)

# "grs" is short for "git reset".
alias grs="git reset"

# "grsh" is short for "git reset --hard".
alias grsh="git reset --hard"

# "grshm" is short for "git reset --hard origin/main".
grshm() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert-in-git-repository
  assert-feature-branch

  local main_branch_name
  main_branch_name=$(get-main-branch-name)

  git reset --hard "origin/$main_branch_name"
  git push --force-with-lease
)

# "grt" is short for "git restore". It will the feature branch's merge base as the source.
grt() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert-in-git-repository
  assert-feature-branch

  if [[ -z "${1-}" ]]; then
    echo "Error: One or more file paths are required." >&2
    return 1
  fi

  local merge_base
  merge_base=$(get-merge-base)

  # We use "git checkout" instead of "git restore" since it works in more situations.
  git checkout "$merge_base" -- "$@"
)

# "grv" is short for "git revert".
grv() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert-in-git-repository

  if [[ -z "${1:-}" ]]; then
    echo "Error: Commit SHA1 is required. Usage: ${FUNCNAME[0]} <commit_sha1>" >&2
    return 1
  fi
  local commit_sha1="$1"

  git revert "$commit_sha1"
  git push
)

# "grva" is short for "git revert --abort".
alias grva="git revert --abort"

# "grvc" is short for "git revert --continue". (It will automatically add all files for you.)
grvc() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert-in-git-repository

  git add --all
  git revert --continue
)

# "grvl" is short for "git revert last". ("grh" is already taken by another command.)
grvl() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert-in-git-repository

  # "--no-edit" avoids prompting for a commit message and uses the default commit message.
  git revert HEAD --no-edit
  git push
  gcs
)

# "gs" is short for "git status --porcelain". (The "--porcelain" flag is preferred since the output
# is more terse.)
alias gs="git status --porcelain"

# "gsq" stands for "git squash", to squash N commits together.
gsq() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert-in-git-repository

  if [[ -z "${1:-}" ]]; then
    echo "Error: You must provide the number of commits to squash." >&2
    return 1
  fi
  local number_of_commits="$1"

  local commit_message
  if [[ -z "${2:-}" ]]; then
    commit_message="chore: squash $number_of_commits commits"
  else
    commit_message="$2"
  fi

  git reset --soft "HEAD~$number_of_commits"
  git commit --message "$commit_message"
  git push --force-with-lease
)

# "gst" is short for "git stash".
alias gst="git stash"

# "gstd" is short for "git stash drop".
alias gstd="git stash drop"

# "gstl" is short for "git stash list".
alias gstl="git stash list"

# "gstp" is short for "git stash pop"
alias gstp="git stash pop"

# "gsw" is short for "git switch". It requires an argument of the number corresponding to the
# alphabetical local branch. ("gs" is already taken by another command.)
gsw() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert-in-git-repository

  local main_branch_name
  main_branch_name=$(get-main-branch-name)

  if [[ -z "${1:-}" ]]; then
    echo "Error: Branch name or number is required. Usage: ${FUNCNAME[0]} <branch-name-or-number>" >&2
    return 1
  fi
  local branch_name_or_number="$1"

  local branch_name
  branch_name=$(get-branch-name-from-number "$branch_name_or_number")

  git switch "$branch_name"
)

# "gswc" is short for "git switch -c". (However, the "gb" command should be used in most contexts.)
alias gswc="git switch -c"

# "gswm" is short for "git switch main".
gswm() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert-in-git-repository

  local main_branch_name
  main_branch_name=$(get-main-branch-name)

  if [[ -n "$(git status --porcelain)" ]]; then
    echo "The repository is not clean. Stashing all of your existing changes."
    git stash push --message "Auto-stash before switching to $main_branch_name"
  fi

  if [[ "$(git branch --show-current)" != "$main_branch_name" ]]; then
    git switch "$main_branch_name"
  fi

  if git remote get-url upstream &> /dev/null; then
    gh-sync
  else
    git pull --rebase
  fi

  gbc --skip-fetch # git branch clean
  git stash list
)

# "gtc" is short for "git tags clean", which will remote all local tags that do not exist on the
# remote repository.
# https://stackoverflow.com/questions/1841341/remove-local-git-tags-that-are-no-longer-on-the-remote-repository
gtc() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert-in-git-repository

  git tag -l | xargs git tag -d
  git fetch --tags

  echo
  echo "Current git tags:"
  git tag
)

# "gu" is short for "git push".
alias gu="git push"

# "guf" is short for "git push --force-with-lease".
alias guf="git push --force-with-lease"

# endregion

# region: GitHub Commands
# ---------------
# GitHub Commands
# ---------------

# This will delete local branches that have been merged via pull requests on GitHub.
gh-clean() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert-in-github-repository
  assert-main-branch

  if ! git remote get-url upstream &> /dev/null; then
    echo "Error: There is no upstream remote. This command is intended to be used inside a forked GitHub repository." >&2
    return 1
  fi

  local main_branch_name
  main_branch_name=$(get-main-branch-name)

  if ! command -v gh &> /dev/null; then
    echo "Error: GitHub CLI (gh) is not installed or not in PATH." >&2
    return 1
  fi

  if ! gh auth status &> /dev/null; then
    echo "Error: Not authenticated with GitHub. Run: gh auth login" >&2
    return 1
  fi

  local my_merged_object_ids
  my_merged_object_ids=$(gh pr list --author @me --state merged --json headRefOid --jq ".[].headRefOid")

  if [[ -z "$my_merged_object_ids" ]]; then
    return
  fi

  local local_branches
  local_branches=$(git branch --format="%(refname:lstrip=2)" | sort)

  while IFS= read -r branch; do
    if [[ "$branch" == "$main_branch_name" ]]; then
      continue
    fi

    local branch_object_id
    branch_object_id=$(git rev-parse "$branch")

    if echo "$my_merged_object_ids" | grep --line-regexp --quiet "$branch_object_id"; then
      echo "GitHub pull request branch has been merged on the upstream: $branch"

      git branch --delete --force "$branch"
      echo "Deleted local branch: $branch"
      git push origin ":$branch"
      echo "Deleted remote branch: $branch"
    fi

  done <<< "$local_branches"
)

# This is a custom version of "gh pr checkout". This is necessary because "gh pr checkout" will fail
# if the forked repository branch name overlaps with a branch name on the upstream repository (and
# the remote has already been added by "set-gh-remote"). To work around this, we can checkout the
# forked repository branch with a custom arbitrary name matching the pull request number.
gh-pr() (
  set -euo pipefail # Exit on errors and undefined variables.

  if [[ -z "${1:-}" ]]; then
    echo "Error: The pull request number is required. Usage: ${FUNCNAME[0]} <pull_request_number>" >&2
    return 1
  fi
  local pull_request_number="$1"

  assert-in-github-repository
  gh pr checkout "$pull_request_number" --branch "pr-$pull_request_number"
  set-gh-remote
)

# This will sync a forked repository's main branch with the upstream. (This is a common operation
# when working on GitHub.)
gh-sync() (
  set -euo pipefail # Exit on errors and undefined variables.

  assert-in-github-repository
  assert-main-branch

  if ! git remote get-url upstream &> /dev/null; then
    echo "Error: There is no upstream remote. This command is intended to be used inside a forked GitHub repository." >&2
    return 1
  fi

  local main_branch_name
  main_branch_name=$(get-main-branch-name)

  git fetch origin --prune --quiet
  git fetch upstream --prune --quiet

  local local_head
  local_head=$(git rev-parse HEAD)
  local remote_head
  remote_head=$(git rev-parse "upstream/$main_branch_name")

  if [[ "$local_head" != "$remote_head" ]]; then
    git rebase "upstream/$main_branch_name"
    git push origin "$main_branch_name" --force-with-lease
  fi
)

# endregion

# region: Pulumi Commands
# ---------------
# Pulumi Commands
# ---------------

# "pd" is short for "pulumi destroy".
alias pd="pulumi destroy"

# "pp" is short for "pulumi preview".
alias pp="pulumi preview"

# "pu" is short for "pulumi up".
alias pu="pulumi up"

# "puy" is short for "pulumi up --yes".
alias puy="pulumi up --yes"

# endregion

# region: Terraform Commands
# ------------------
# Terraform Commands
# ------------------

# "ta" is short for "terraform apply".
alias ta="terraform apply"

# "taa" is short for "terraform apply -auto-approve".
alias taa="terraform apply -auto-approve"

# "tc" is short for "terraform clean".
alias tc="rm -rf .terraform .terraform.lock.hcl terraform.tfstate terraform.tfstate.backup"

# "td" is short for "terraform destroy".
alias td="terraform destroy"

# "tda" is short for "terraform destroy -auto-approve".
alias tda="terraform destroy -auto-approve"

# "tf" is short for "terraform fmt".
alias tf="terraform fmt"

# "ti" is short for "terraform init".
alias ti="terraform init"

# "tp" is short for "terraform plan".
alias tp="terraform plan"

# "tv" is short for "terraform validate".
alias tv="terraform validate"

# endregion
